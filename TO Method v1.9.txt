 // @version=5

indicator(title="TraderOracle Method", shorttitle="TO Method v1.9", overlay=true)
 
bShowCloud = input.bool(true, "Show Resistance Cloud", group="Basic Settings", tooltip="Resistance/support cloud")
bShowSqueeze = input.bool(true, "Show Squeeze Relaxer Dots", group="Basic Settings", tooltip="Reversal indicator, based upon the TTM Squeeze")
bShowShark = input.bool(false, "Show Shark Icons", group="Basic Settings")
bShowEMA = input.bool(true, "Show 200 EMA and VWAP", group="Basic Settings")
bShowTramp = input.bool(true, "Show Trampoline", group="Basic Settings", tooltip="Reversal indicator")
bShowPivotPoints = input.bool(false, title="Show Pivot Points", group="Basic Settings", tooltip="Previous day's high/low, frequently bounced off of")
bShowEverest = input.bool(false, title="Show Everest", group="Basic Settings", tooltip="Trend indicator")
bShowVodka = input.bool(true, title="Show VodkaShot", group="Basic Settings", tooltip="Trend indicator")
bShowEarlyReversal = input.bool(false, title="Show Early Reversal", group="Basic Settings", tooltip="Shows rejection of a higher/lower zone")
bShowWVMA = input.bool(false, title="Show WVMA line", group="Basic Settings", tooltip="A fantastic support/resistance line for trading NASDAQ futures")
sCandleType = input.string(title="Candle Type", options=["Default","Vector","Wave"], group="Basic Settings", defval="Default", tooltip="If you choose VECTOR, please ensure your candle bodies are BLANK under TradingView settings")

line_width = input.int(1, title="Pivot Point Line Width", group="Advanced Settings")

bUseBB = input.bool(false, "Use Bollinger Bands", group="Wicking Settings")
bUseKC = input.bool(false, "Use Keltner Channels", group="Wicking Settings")
bUseRSI = input.bool(false, "Use RSI", group="Wicking Settings")

rsiLowerW = input.int(30, "Lower Limit of RSI", minval = 1, maxval = 500, group="Wicking Settings")
rsiUpperW = input.int(70, "Upper Limit of RSI", minval = 1, maxval = 500, group="Wicking Settings")

// Determine wick size (that's what SHE said)
upWickPercentLarger = close > open and math.abs(high - close) > math.abs(low - open) // math.abs(open - close)
downWickPercentLarger = close < open and math.abs(low - close) > math.abs(open - high) // math.abs(open - close)

lenG = input.int(175, "Length", minval=1, group="VWMA Settings")
srcG = input(close, "Source", group="VWMA Settings")
maG = ta.vwma(srcG, lenG)
offset = input.int(0, "Offset", minval = -500, maxval = 500)
plot(bShowWVMA ? maG : na, title="VWMA", color=#6d29ff, offset = offset, linewidth = 2)


// =-=-=-=-=-=-=-=-=-=-=-=-=  WAVE CANDLES  =-=-=-=-=-=-=-=-=-=-=-=-=-= //

const int upTrend = 1
const int downTrend = 2

var int waveState = na

bool iss = true

redCandle = close < open
greenCandle = close > open
noOverlapRed = false
noOverlapGreen = false

brightGreen = false
brightRed = false

if (iss and greenCandle and open > close[1] and greenCandle[1])
    noOverlapGreen := true
    waveState := upTrend

if (iss and redCandle and open > close[1] and redCandle[1])
    noOverlapRed := true
    waveState := downTrend

if (iss and greenCandle)
    for i = 1 to 200
        if (brightRed[i]) // if bright red candle, stop
            break
        else if (waveState==upTrend and redCandle[i]) // if we're in a uptrend, and the candle is red, stop
            break
        else if (waveState==downTrend and open > close[i] and greenCandle[i])
            noOverlapGreen := true
            waveState := upTrend
            break

if (iss and redCandle)
    for i = 1 to 200
        if (brightGreen[i]) // if bright green candle, stop
            break
        else if (waveState==downTrend and greenCandle[i]) // if we're in a downtrend, and the candle is green, stop
            break
        else if (waveState==upTrend and open < close[i] and redCandle[i])
            noOverlapRed := true
            waveState := downTrend
            break

barcolor(sCandleType=="Wave" and noOverlapRed ? color.red : sCandleType=="Wave" and noOverlapGreen ? color.lime : na)

if (iss and noOverlapGreen)
    brightGreen := true

if (iss and noOverlapRed)
    brightRed := true


// =-=-=-=-=-=-=-=-=-=-=-=-=  LuxAlgo - Market Structure (Fractal)  =-=-=-=-=-=-=-=-=-=-=-=-=-= //

var float upOpen = na
var float upClose = na
var float downOpen = na
var float downClose = na

bGreenSignal = false
bRedSignal = false

length = 5 // default, min 3

type fractal
    float value
    int loc
    bool iscrossed

var pT = int(length / 2)
n = bar_index
dhT = math.sum(math.sign(high - high[1]), pT)
dlT = math.sum(math.sign(low - low[1]), pT)
bullf = dhT == -pT and dhT[pT] == pT and high[pT] == ta.highest(length)
bearf = dlT == pT and dlT[pT] == -pT and low[pT] == ta.lowest(length)
bullf_count = ta.cum(bullf ? 1 : 0)
bearf_count = ta.cum(bearf ? 1 : 0)


// CHoCH upwards
var upperT = fractal.new()
var line lower_lvl = na
var label ms_lbl = na
var bull_ms_count = 0
var broken_sup = false
var os = 0

if bullf
    upperT.value := high[pT]
    upperT.loc := n-pT
    upperT.iscrossed := false

if ta.crossover(close, upperT.value) and not upperT.iscrossed
    upOpen := open
    upClose := close
    //line.new(upper.loc, upper.value, n, upper.value, color = color.lime)
else if not broken_sup
    lower_lvl.set_x2(n)
    if close < lower_lvl.get_y2()
        broken_sup := true


// CHoCH downwards
var lowerT = fractal.new()
var line upper_lvl = na
var broken_res = false
var bear_ms_count = 0

if bearf
    lowerT.value := low[pT]
    lowerT.loc := n-pT
    lowerT.iscrossed := false

if ta.crossunder(close, lowerT.value) and not lowerT.iscrossed
    downOpen := open
    downClose := close
    //line.new(lower.loc, lower.value, n, lower.value, color = color.red)
else if not broken_res
    upper_lvl.set_x2(n)
    if close > upper_lvl.get_y2()
        broken_res := true


// =-=-=-=-=-=-=  Nadaraya-Watson: Envelope (Non-Repainting) Â© jdehorty  =-=-=-=-=-=-=-=-= //

h = input.float(6, "Smoothing Factor", step = .5, tooltip = "The bandwith(h) used in the kernel of the Nadaraya-Watson estimator function." ,group = "Cloud Settings")
repaint = input.bool(false,"Repaint Smoothing", tooltip = "This setting allows for repainting of the estimation" , group = "Cloud Settings")
sens = 4

short_period = input.int(20, "Period", inline = "short", group = "Cloud Settings")
short_stdev = input.float(3, "Deviation", inline = "short", group = "Cloud Settings")
med_period = input.int(75, "Period", inline = "med", group = "Cloud Settings")
med_stdev = input.float(4, "Deviation", inline = "med", group = "Cloud Settings")
long_period = input.int(100, " Period", inline = "long", group = "Cloud Settings")
long_stdev = input.float(4.25, "Deviation", inline = "long", group = "Cloud Settings")

pallete_bear = input.color(color.red, "Bearish", inline = "theme", group = "Cloud Settings")
pallete_bull = input.color(color.green, "Bullish", inline = "theme", group = "Cloud Settings")
alpha1 = input.float(.90, "Transparency: Level 1 ", minval = .1, maxval = 1,inline = "alpha", step = .1, group = "Cloud Settings")
alpha2 = input.float(.85, "Level 2", minval = .1, maxval = 1, inline = "alpha", step = .1, group = "Cloud Settings")

type pallete 
    color bear
    color bull 
    color shade1_bear 
    color shade1_bull 
    color shade2_bear 
    color shade2_bull

create_pallete(color bear, color bull, float alpha1 = 1, float alpha2 = 2) =>
    float shade1 = 100 * alpha1
    float shade2 = 100 * alpha2
    color shade1_bear = color.new(bear, shade1)
    color shade1_bull = color.new(bull, shade1)
    color shade2_bear = color.new(bear, shade2)
    color shade2_bull = color.new(bull, shade2)
    pallete.new(bear, bull, shade1_bear, shade1_bull, shade2_bear, shade2_bull)
    
theme = create_pallete(pallete_bear, pallete_bull, alpha1, alpha2)

const bool bollinger_bands_lvl1 = true
const bool bollinger_bands_lvl2 = true
float tp = (high + low + close) /3

int n_first = 20 
int n_second = 75 
int n_third = 100

guass_w(x, h) => 
   math.exp (-1 *( (x*x) / (2*(h*h)) ))

bollingers(n, factor = 3) =>
    bolu = ta.sma(tp, n) + (factor * ta.stdev(tp, n))
    bold = ta.sma(tp, n) - (factor * ta.stdev(tp, n))
    [bolu, bold]

[BOLU_FIRST, BOLD_FIRST] = bollingers(n_first, short_stdev) 
float BOL_FIRST_GAP = BOLU_FIRST - BOLD_FIRST

[BOLU_SECOND, BOLD_SECOND] = bollingers(n_second, short_stdev) 
float BOL_SECOND_GAP = BOLU_SECOND - BOLD_SECOND

[BOLU_THIRD, BOLD_THIRD] = bollingers(n_third, med_stdev) 
float BOL_THIRD_GAP = BOLU_THIRD - BOLD_THIRD

[BOLU_FOURTH, BOLD_FOURTH] = bollingers(n_third, long_stdev) 

var pivots = array.new<float>()
var pivots2 = array.new<float>()

pivot_rad = sens

float pivot_high = ta.pivothigh(high, pivot_rad, pivot_rad)
float pivot_low = ta.pivotlow(low, pivot_rad, pivot_rad)

add_cols(mat, h_n = 1) =>
    sum_array = array.new<float>()
    for i=0 to matrix.rows(mat)-1
        array.push(sum_array, array.sum(matrix.row(mat, i))/h_n)
    sum_array

nadaraya(src, color) =>
    smoothed = array.new<float>() 
    if barstate.islast and repaint
        for i=0 to 499
            sum = 0.
            gk = array.new<float>()
            for y =0 to 499
                gk.push(guass_w(y - i, h))
            gk_sum = gk.sum()
            for y =0 to 499
                sum += src[y]*(gk.get(y)/gk_sum)
            smoothed.push(sum)
            if i%2 == 0 and i != 0
                line.new(bar_index[i-1], smoothed.get(i-1), bar_index[i], smoothed.get(i), color = color, width = 2)
    smoothed

running_nadaraya(src, n)=>
    var gk = array.new<float>(0)
    var gk_sum =  0.
    var src_matrix = matrix.new<float>()
    smoothed = 0.
    if barstate.isfirst and not repaint
        for i=0 to n
            gk.push(guass_w(i, h))
        gk_sum := gk.sum()
    if not repaint
        for i=n to 0
            smoothed += src[i] * (gk.get(i)/gk_sum)
    smoothed 

n11 = 499

smoothed_bolu_1 = running_nadaraya(BOLU_FIRST, n11)
smoothed_bold_1 = running_nadaraya(BOLD_FIRST, n11)

smoothed_bolu_2 = running_nadaraya(BOLU_SECOND, n11)
smoothed_bold_2 = running_nadaraya(BOLD_SECOND, n11)

smoothed_bolu_3 = running_nadaraya(BOLU_THIRD, n11)
smoothed_bold_3 = running_nadaraya(BOLD_THIRD, n11)

smoothed_bolu_4 = running_nadaraya(BOLU_FOURTH, n11)
smoothed_bold_4 = running_nadaraya(BOLD_FOURTH, n11)

BOLU_FIRST_PLOT = plot(smoothed_bolu_1, display = display.none)
BOLD_FIRST_PLOT = plot(smoothed_bold_1, display = display.none)

BOLU_SECOND_PLOT = plot(smoothed_bolu_2, display = display.none)
BOLD_SECOND_PLOT = plot(smoothed_bold_2, display = display.none)

BOLU_THIRD_PLOT = plot(smoothed_bolu_3, display = display.none)
BOLD_THIRD_PLOT = plot(smoothed_bold_3, display = display.none)

BOLU_FOURTH_PLOT = plot(smoothed_bolu_4, display = display.none)
BOLD_FOURTH_PLOT = plot(smoothed_bold_4, display = display.none)

spacing = ta.atr(300)

upper_band_test = pivot_high >= smoothed_bolu_1[sens] and not repaint ? pivot_high + spacing * 1.01  : na
lower_band_test = pivot_low  <= smoothed_bold_1[sens] and not repaint ? pivot_low - spacing * 1.01  : na

fill(BOLU_FIRST_PLOT, BOLU_SECOND_PLOT, theme.shade1_bear, display = bShowCloud ? display.all : display.none)
fill(BOLD_FIRST_PLOT, BOLD_SECOND_PLOT, theme.shade1_bull, display = bShowCloud ? display.all : display.none)
fill(BOLU_SECOND_PLOT, BOLU_THIRD_PLOT, theme.shade2_bear, display = bShowCloud ? display.all : display.none)
fill(BOLD_SECOND_PLOT, BOLD_THIRD_PLOT, theme.shade2_bull, display = bShowCloud ? display.all : display.none)

bBrokeUp = high > smoothed_bolu_1
bBrokeDown = low < smoothed_bold_1


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=   TRAMPOLINE  =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= //

// Idea from "Serious Backtester" - https://www.youtube.com/watch?v=2hX7qTamOAQ
// Defaults are optimized for 30 min candles

// CONFIG
iBBThreshold = input.float(0.0015, minval=0.0, title="Bollinger Lower Threshold", tooltip="0.003 for daily, 0.0015 for 30 min candles", group="TRAMPOLINE Settings")
RSIThreshold = input.int(25, minval=1, title="RSI Lower Threshold", tooltip="Normally 25", group="TRAMPOLINE Settings")
RSIDown = input.int(72, minval=1, title="RSI Upper Threshold", tooltip="Normally 75", group="TRAMPOLINE Settings")

rsiLengthInput = input.int(14, minval=1, title="RSI Length", group="TRAMPOLINE Settings")
rsiSourceInput = input(close, "RSI Source", group="TRAMPOLINE Settings")
lengthBB = input.int(20, minval=1, group="TRAMPOLINE Bollinger Bands")
srcBB = input(close, title="Source", group="TRAMPOLINE Bollinger Bands")
multBB = input.float(2.0, minval=0.001, maxval=50, title="StdDev", group="TRAMPOLINE Bollinger Bands")
offsetBB = input.int(0, "Offset", minval = -500, maxval = 500, group="TRAMPOLINE Bollinger Bands")

isRed = close < open
isGreen = close > open

// STANDARD BOLLINGER BANDS
basisBB = ta.sma(srcBB, lengthBB)
devBB = multBB * ta.stdev(srcBB, lengthBB)
upperBB = basisBB + devBB
lowerBB = basisBB - devBB
downBB = low < lowerBB or high < lowerBB
upBB = low > upperBB or high > upperBB
bbw = (upperBB - lowerBB) / basisBB

// RSI
up = ta.rma(math.max(ta.change(rsiSourceInput), 0), rsiLengthInput)
down = ta.rma(-math.min(ta.change(rsiSourceInput), 0), rsiLengthInput)
rsiM = down == 0 ? 100 : up == 0 ? 0 : 100 - (100 / (1 + up / down))

back1 = isRed[1] and rsiM[1] <= RSIThreshold and close[1] < lowerBB[1] and bbw[1] > iBBThreshold
back2 = isRed[2] and rsiM[2] <= RSIThreshold and close[2] < lowerBB[2] and bbw[2] > iBBThreshold
back3 = isRed[3] and rsiM[3] <= RSIThreshold and close[3] < lowerBB[3] and bbw[3] > iBBThreshold
back4 = isRed[4] and rsiM[4] <= RSIThreshold and close[4] < lowerBB[4] and bbw[4] > iBBThreshold
back5 = isRed[5] and rsiM[5] <= RSIThreshold and close[5] < lowerBB[5] and bbw[5] > iBBThreshold

for1 = isGreen[1] and rsiM[1] >= RSIDown and close[1] > upperBB[1] and bbw[1] > iBBThreshold
for2 = isGreen[2] and rsiM[2] >= RSIDown and close[2] > upperBB[2] and bbw[2] > iBBThreshold
for3 = isGreen[3] and rsiM[3] >= RSIDown and close[3] > upperBB[3] and bbw[3] > iBBThreshold
for4 = isGreen[4] and rsiM[4] >= RSIDown and close[4] > upperBB[4] and bbw[4] > iBBThreshold
for5 = isGreen[5] and rsiM[5] >= RSIDown and close[5] > upperBB[5] and bbw[5] > iBBThreshold

weGoUp = isGreen and (back1 or back2 or back3 or back4 or back5) and (high > high[1]) and barstate.isconfirmed
upThrust = weGoUp and not weGoUp[1] and not weGoUp[2] and not weGoUp[3] and not weGoUp[4]
weGoDown = isRed and (for1 or for2 or for3 or for4 or for5) and (low < low[1]) and barstate.isconfirmed
downThrust = weGoDown and not weGoDown[1] and not weGoDown[2] and not weGoDown[3] and not weGoDown[4]

// PLOT THE THINGS
plotshape(bShowTramp and upThrust ? hl2 : na, title="Trampoline", text="T", location=location.belowbar, style=shape.labelup, size=size.tiny, color=color.rgb(46, 173, 84), textcolor=color.white)
plotshape(bShowTramp and downThrust ? hl2 : na, title="Trampoline", text="T", location=location.abovebar, style=shape.labeldown, size=size.tiny, color=color.rgb(173, 46, 69), textcolor=color.white)


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=   Squeeze Relaxer version 2.1  =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= //

// Average Directional Index
sqTolerance = input.int(2, title="Squeeze Tolerance (lower = more sensitive)", group="Relaxing Settings", tooltip="How many bars to look back on the squeeze indicator")
adxSqueeze = input.int(21, title="ADX Threshold for TTM Squeeze", group="Relaxing Settings", tooltip="Anything over 19 filters out low volume periods. Set to 11 as a default, feel free to increase to get less noise")

adxlen = input(14, title="ADX Smoothing", group="ADX")
dilen = input(14, title="DI Length", group="ADX")
dirmov(len) =>
	up5 = ta.change(high)
	down5 = -ta.change(low)
	plusDM = na(up5) ? na : (up5 > down5 and up5 > 0 ? up5 : 0)
	minusDM = na(down5) ? na : (down > up5 and down5 > 0 ? down5 : 0)
	truerange = ta.rma(ta.tr, len)
	plus = fixnan(100 * ta.rma(plusDM, len) / truerange)
	minus = fixnan(100 * ta.rma(minusDM, len) / truerange)
	[plus, minus]
adx(dilen, adxlen) =>
	[plus, minus] = dirmov(dilen)
	sum = plus + minus
	adx = 100 * ta.rma(math.abs(plus - minus) / (sum == 0 ? 1 : sum), adxlen)
adxValue = adx(dilen, adxlen)
sigabove19 = adxValue > adxSqueeze

var cGreen = 0
var cRed = 0
var pos = false 
var neg = false 

sqlength = 20
multQ = 2.0
lengthKC = 20
multKC = 1.5

useTrueRange = true
source = close
basis = ta.sma(source, sqlength)
dev1 = multKC * ta.stdev(source, sqlength)
upperBBsq = basis + dev1
lowerBBsq = basis - dev1
ma = ta.sma(source, lengthKC)
rangeQ = high - low
rangema = ta.sma(rangeQ, lengthKC)
upperKC = ma + rangema * multKC
lowerKC = ma - rangema * multKC
sqzOn  = (lowerBBsq > lowerKC) and (upperBBsq < upperKC)
sqzOff = (lowerBBsq < lowerKC) and (upperBBsq > upperKC)
noSqz  = (sqzOn == false) and (sqzOff == false)

avg1 = math.avg(ta.highest(high, lengthKC), ta.lowest(low, lengthKC))
avg2 = math.avg(avg1, ta.sma(close, lengthKC))
val = ta.linreg(close - avg2, lengthKC, 0)

pos := false
neg := false

// if squeeze is bright RED, increment by one
if (val < nz(val[1]) and val < 5 and not sqzOn)
    cRed := cRed + 1   

// if squeeze is bright GREEN, increment by one
if (val > nz(val[1]) and val > 5 and not sqzOn)
    cGreen := cGreen + 1   

// if bright RED squeeze is now dim, momentum has changed.  Is ADX also above 19? - add a marker to chart
if (val > nz(val[1]) and cRed > sqTolerance and val < 5 and not pos[1] and sigabove19 == true)
    cRed := 0
    pos := true  

// if bright GREEN squeeze is now dim, momentum has changed.  Is ADX also above 19? - add a marker to chart
if (val < nz(val[1]) and cGreen > sqTolerance and val > 5 and not neg[1] and sigabove19 == true)
    cGreen := 0
    neg := true  

buySignal1 = pos and barstate.isconfirmed
sellSignal1 = neg and barstate.isconfirmed



// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=   VECTOR CANDLES  =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= //

import TradersReality/Traders_Reality_Lib/2 as trLib

color redVectorColor = input.color(title='Vector: Red', defval=color.rgb(255, 0, 0), inline='vectors', group="Vector Candle Settings")
color greenVectorColor = input.color(title='Green',defval=color.rgb(0, 255, 132), inline='vectors', group="Vector Candle Settings")
color violetVectorColor = input.color(title='Violet',defval=color.fuchsia, inline='vectors', group="Vector Candle Settings")
color blueVectorColor = input.color(title='Blue', defval=color.rgb(83, 144, 249), inline='vectors', tooltip='Bull bars are green and bear bars are red when the bar is with volume >= 200% of the average volume of the 10 previous bars, or bars where the product of candle spread x candle volume is >= the highest for the 10 previous bars.\n Bull bars are blue and bear are violet when the bar is with with volume >= 150% of the average volume of the 10 previous bars.', group="Vector Candle Settings")
color regularCandleUpColor = input.color(title='Regular: Up Candle', defval=color.new(#999999, 99), inline='nonVectors', group="Vector Candle Settings")
color regularCandleDownColor = input.color(title='Down Candle', defval=color.new(#4d4d4d, 99), inline='nonVectors', tooltip='Bull bars are light gray and bear are dark gray when none of the red/green/blue/violet vector conditions are met.', group="Vector Candle Settings")

bool overrideSym = input.bool(title='Override chart symbol?', defval=false, inline='pvsra', group="Vector Candle Settings")
string pvsraSym = input.string(title='', defval='INDEX:BTCUSD', tooltip='You can use INDEX:BTCUSD or you can combine multiple feeds, for example BINANCE:BTCUSDT+COINBASE:BTCUSD. Note that adding too many will slow things down.', inline='pvsra', group="Vector Candle Settings")
bool colorOverride = input.bool(true, 'Override color?' , inline="vcz1", group="Vector Candle Settings")

pvsraVolume(overrideSymbolX, pvsraSymbolX, tickerIdX) =>
    request.security(overrideSymbolX ? pvsraSymbolX : tickerIdX, '', [volume,high,low,close,open], barmerge.gaps_off, barmerge.lookahead_off)

[pvsraVolume, pvsraHigh, pvsraLow, pvsraClose, pvsraOpen]  = pvsraVolume(overrideSym, pvsraSym, syminfo.tickerid)

[pvsraColor, alertFlag, averageVolume, volumeSpread, highestVolumeSpread] = trLib.calcPvsra(pvsraVolume, pvsraHigh, pvsraLow, pvsraClose, pvsraOpen, redVectorColor, greenVectorColor, violetVectorColor, blueVectorColor, regularCandleDownColor, regularCandleUpColor)

bVectorGreen = pvsraColor == greenVectorColor
bVectorRed = pvsraColor == redVectorColor



// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=   TOTAL RECALL  =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= //

bFinalColor = color.yellow

if (bVectorGreen and (close[0] == upClose[0] or close[1] == upClose[1] or close[2] == upClose[2] or close[3] == upClose[3]))
    bGreenSignal := true
plotshape(bGreenSignal and bShowEarlyReversal and barstate.isconfirmed ? 1 : na, title="Reversal Approaching", style=shape.cross, location=location.abovebar, color=bFinalColor, size=size.tiny)
//plotcandle(open, high, low, close, "", color=pvsraColor, wickcolor=pvsraColor, bordercolor=color.rgb(255, 0, 0))

if (bVectorRed and (close[0] == downClose[0] or close[1] == downClose[1] or close[2] == downClose[2] or close[3] == downClose[3]))
    bRedSignal := true
plotshape(bRedSignal and bShowEarlyReversal and barstate.isconfirmed ? 1 : na, title="Reversal Approaching", style=shape.cross, location=location.belowbar, color=bFinalColor, size=size.tiny)
//plotcandle(open, high, low, close, "", color=pvsraColor, wickcolor=pvsraColor, bordercolor=color.rgb(0, 255, 132))

barcolor(sCandleType=="Vector" ? pvsraColor : na)

bSqueezeColor = color.yellow
if (bGreenSignal[0] or bGreenSignal[1] or bGreenSignal[2] or bGreenSignal[3] or bGreenSignal[4])
    bSqueezeColor := color.rgb(0, 255, 132)
if (bRedSignal[0] or bRedSignal[1] or bRedSignal[2] or bRedSignal[3] or bRedSignal[4])
    bSqueezeColor := color.rgb(0, 255, 132)

plotshape(bShowSqueeze and buySignal1 ? pos : na, title="Squeeze Buy Signal", style=shape.diamond, location=location.belowbar, color=bSqueezeColor, size=size.tiny)
plotshape(bShowSqueeze and sellSignal1 ? neg : na, title="Squeeze Sell Signal", style=shape.diamond, location=location.abovebar, color=bSqueezeColor, size=size.tiny)
 

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=   THE SHARK  =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= //

bApply25and75 = input(false, title="Apply 25/75 RSI rule", group="Shark Settings")

ema50 = ta.ema(close, 50)
ema200 = ta.ema(close, 200)
ema400 = ta.ema(close, 400)
ema800 = ta.ema(close, 800)
wapwap = ta.vwap(close)

bTouchedLine = (ema50<high and ema50>low) or (ema200<high and ema200>low) or (ema400<high and ema400>low) or (ema800<high and ema800>low) or (wapwap<high and wapwap>low)

basis5 = ta.sma(rsiM, 30)
dev = 2.0 * ta.stdev(rsiM, 30)
upper = basis5 + dev
lower = basis5 - dev

bBelow25 = rsiM < 26
bAbove75 = rsiM > 74

if not bApply25and75
    bBelow25 := true
    bAbove75 := true

bShowSharkDown = (rsiM > upper and bAbove75) and barstate.isconfirmed
bShowSharkUp = (rsiM < lower and bBelow25) and barstate.isconfirmed

plotchar(bShowShark and bShowSharkUp ? hlcc4 : na, char="ðŸ¦ˆ", title="Shark", location=location.belowbar, size=size.auto)
plotchar(bShowShark and bShowSharkDown ? hlcc4 : na, char="ðŸ¦ˆ", title="Shark", location=location.abovebar, size=size.auto)


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=   PIVOT POINTS STANDARD  =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= //

AUTO = "Auto"
DAILY = "Daily"
WEEKLY = "Weekly"
MONTHLY = "Monthly"
QUARTERLY = "Quarterly"
YEARLY = "Yearly"
BIYEARLY = "Biyearly"
TRIYEARLY = "Triyearly"
QUINQUENNIALLY = "Quinquennially"
DECENNIALLY = "Decennially"

TRADITIONAL = "Traditional"

custom_years_divisor = 2

kind = TRADITIONAL
pivot_time_frame = AUTO
look_back = 15
is_daily_based = true
show_labels = false
show_prices = false
position_labels = "Left"

var DEF_COLOR = #bb9057
var arr_time = array.new_int()
var p = array.new_float()
var r1 = array.new_float()
var s1 = array.new_float()
var r2 = array.new_float()
var s2 = array.new_float()
var r3 = array.new_float()
var s3 = array.new_float()
var r4 = array.new_float()
var s4 = array.new_float()
var r5 = array.new_float()
var s5 = array.new_float()
pivotX_open = float(na)
pivotX_open := nz(pivotX_open[1], open)
pivotX_high = float(na)
pivotX_high := nz(pivotX_high[1], high)
pivotX_low = float(na)
pivotX_low := nz(pivotX_low[1], low)
pivotX_prev_open = float(na)
pivotX_prev_open := nz(pivotX_prev_open[1])
pivotX_prev_high = float(na)
pivotX_prev_high := nz(pivotX_prev_high[1])
pivotX_prev_low = float(na)
pivotX_prev_low := nz(pivotX_prev_low[1])
pivotX_prev_close = float(na)
pivotX_prev_close := nz(pivotX_prev_close[1])

get_pivot_resolution() =>
    timeframe.multiplier <= 15 ? "D" : "W"

var lines = array.new_line()
var labels = array.new_label()

draw_line(i, pivot, col) =>
    if array.size(arr_time) > 1
        array.push(lines, line.new(array.get(arr_time, i), array.get(pivot, i), array.get(arr_time, i + 1), array.get(pivot, i), color=col, xloc=xloc.bar_time, width=line_width))

traditional() =>
    pivotX_Median = (pivotX_prev_high + pivotX_prev_low + pivotX_prev_close) / 3
    array.push(p, pivotX_Median)
    array.push(r1, pivotX_Median * 2 - pivotX_prev_low)
    array.push(s1, pivotX_Median * 2 - pivotX_prev_high)
    array.push(r2, pivotX_Median + 1 * (pivotX_prev_high - pivotX_prev_low))
    array.push(s2, pivotX_Median - 1 * (pivotX_prev_high - pivotX_prev_low))
    array.push(r3, pivotX_Median * 2 + (pivotX_prev_high - 2 * pivotX_prev_low))
    array.push(s3, pivotX_Median * 2 - (2 * pivotX_prev_high - pivotX_prev_low))
    array.push(r4, pivotX_Median * 3 + (pivotX_prev_high - 3 * pivotX_prev_low))
    array.push(s4, pivotX_Median * 3 - (3 * pivotX_prev_high - pivotX_prev_low))
    array.push(r5, pivotX_Median * 4 + (pivotX_prev_high - 4 * pivotX_prev_low))
    array.push(s5, pivotX_Median * 4 - (4 * pivotX_prev_high - pivotX_prev_low))

calc_pivot() =>
    traditional()

resolution = get_pivot_resolution()

SIMPLE_DIVISOR = 2

calc_high(prev, curr) =>
    if na(prev) or na(curr)
        nz(prev, nz(curr, na))
    else
        math.max(prev, curr)
    
calc_low(prev, curr) =>
    if not na(prev) and not na(curr)
        math.min(prev, curr)
    else
        nz(prev, nz(curr, na))

calc_OHLC_for_pivot(custom_years_divisor) =>
    if custom_years_divisor == SIMPLE_DIVISOR 
        [open, high, low, close, open[1], high[1], low[1], close[1], time[1], time_close]
    else
        var prev_sec_open = float(na)
        var prev_sec_high = float(na)
        var prev_sec_low = float(na)
        var prev_sec_close = float(na)
        var prev_sec_time = int(na)
        var curr_sec_open = float(na)
        var curr_sec_high = float(na)
        var curr_sec_low = float(na)
        var curr_sec_close = float(na)
        if year(time_close) % custom_years_divisor == 0
        	curr_sec_open := open
			curr_sec_high := high
			curr_sec_low := low
			curr_sec_close := close
            prev_sec_high := high[1]
            prev_sec_low := low[1]
            prev_sec_close := close[1]
            prev_sec_time := time[1]
            for i = 2 to custom_years_divisor
                prev_sec_open :=  nz(open[i], prev_sec_open)
                prev_sec_high := calc_high(prev_sec_high, high[i])
                prev_sec_low := calc_low(prev_sec_low, low[i])
                prev_sec_time := nz(time[i], prev_sec_time)
        [curr_sec_open, curr_sec_high, curr_sec_low, curr_sec_close, prev_sec_open, prev_sec_high, prev_sec_low, prev_sec_close, prev_sec_time, time_close]

[sec_open, sec_high, sec_low, sec_close, prev_sec_open, prev_sec_high, prev_sec_low, prev_sec_close, prev_sec_time, sec_time] = request.security(syminfo.tickerid, resolution, calc_OHLC_for_pivot(custom_years_divisor), lookahead = barmerge.lookahead_on)
sec_open_gaps_on = request.security(syminfo.tickerid, resolution, open, gaps = barmerge.gaps_on, lookahead = barmerge.lookahead_on)

is_change_years = false
var is_change = false
var uses_current_bar = false
var change_time = int(na)
is_time_change = false

var start_time = time
var was_last_premarket = false
var start_calculate_in_premarket = false

is_last_premarket = barstate.islast and session.ispremarket and time_close > sec_time and not was_last_premarket

if is_last_premarket
    was_last_premarket := true
    start_calculate_in_premarket := true
if session.ismarket
    was_last_premarket := false
    
without_time_change = barstate.islast and array.size(arr_time) == 0
is_can_calc_pivot = (not uses_current_bar and is_time_change and session.ismarket) or (ta.change(sec_open) and not start_calculate_in_premarket) or is_last_premarket or (uses_current_bar and not na(sec_open_gaps_on)) or without_time_change
enough_bars_for_calculate = prev_sec_time >= start_time or is_daily_based

if is_can_calc_pivot and enough_bars_for_calculate 
    if array.size(arr_time) == 0 and is_daily_based
        pivotX_prev_open := prev_sec_open[1]
        pivotX_prev_high := prev_sec_high[1]
        pivotX_prev_low := prev_sec_low[1]
        pivotX_prev_close := prev_sec_close[1]
        pivotX_open := sec_open[1]
        pivotX_high := sec_high[1]
        pivotX_low := sec_low[1]
        array.push(arr_time, start_time)
        calc_pivot()
    
    if is_daily_based
    	if is_last_premarket
            pivotX_prev_open := sec_open
            pivotX_prev_high := sec_high
            pivotX_prev_low := sec_low
            pivotX_prev_close := sec_close
            pivotX_open := open
            pivotX_high := high
            pivotX_low := low
        else
			pivotX_prev_open := prev_sec_open
			pivotX_prev_high := prev_sec_high
			pivotX_prev_low := prev_sec_low
			pivotX_prev_close := prev_sec_close
			pivotX_open := sec_open
			pivotX_high := sec_high
			pivotX_low := sec_low
    else
        pivotX_prev_high := pivotX_high
        pivotX_prev_low := pivotX_low
        pivotX_prev_open := pivotX_open
        pivotX_prev_close := close[1]
        pivotX_open := open
        pivotX_high := high
        pivotX_low := low

    if barstate.islast and not is_change and array.size(arr_time) > 0 and not without_time_change
        array.set(arr_time, array.size(arr_time) - 1, change_time)
    else if without_time_change
        array.push(arr_time, start_time)
    else
        array.push(arr_time, nz(change_time, time))

    calc_pivot()

    if array.size(arr_time) > look_back
        if array.size(arr_time) > 0
            array.shift(arr_time)
        if array.size(p) > 0 
            array.shift(p)
        if array.size(r1) > 0 
            array.shift(r1)
        if array.size(s1) > 0 
            array.shift(s1)
        if array.size(r2) > 0 
            array.shift(r2)
        if array.size(s2) > 0 
            array.shift(s2)
        if array.size(r3) > 0 
            array.shift(r3)
        if array.size(s3) > 0
            array.shift(s3)
        if array.size(r4) > 0 
            array.shift(r4)
        if array.size(s4) > 0 
            array.shift(s4)
        if array.size(r5) > 0
            array.shift(r5)
        if array.size(s5) > 0
            array.shift(s5)
    is_change := true
else if not is_daily_based
    pivotX_high := math.max(pivotX_high, high)
    pivotX_low := math.min(pivotX_low, low)

if barstate.islast and array.size(arr_time) > 0 and is_change
    is_change := false
    array.push(arr_time, time_close(resolution))

    for i = 0 to array.size(lines) - 1
        if array.size(lines) > 0
            line.delete(array.shift(lines))
        if array.size(labels) > 0
            label.delete(array.shift(labels))

    for i = 0 to array.size(arr_time) - 2
        if array.size(p) > 0 and bShowPivotPoints
            draw_line(i, p, DEF_COLOR)
        if array.size(r1) > 0 and bShowPivotPoints 
            draw_line(i, r1, DEF_COLOR)
        if array.size(s1) > 0 and bShowPivotPoints
            draw_line(i, s1, DEF_COLOR)
        if array.size(r2) > 0 and bShowPivotPoints
            draw_line(i, r2, DEF_COLOR)
        if array.size(s2) > 0 and bShowPivotPoints
            draw_line(i, s2, DEF_COLOR)
        if array.size(r3) > 0 and bShowPivotPoints
            draw_line(i, r3, DEF_COLOR)
        if array.size(s3) > 0 and bShowPivotPoints
            draw_line(i, s3, DEF_COLOR)
        if array.size(r4) > 0 and bShowPivotPoints
            draw_line(i, r4, DEF_COLOR)
        if array.size(s4) > 0 and bShowPivotPoints
            draw_line(i, s4, DEF_COLOR)
        if array.size(r5) > 0 and bShowPivotPoints
            draw_line(i, r5, DEF_COLOR)
        if array.size(s5) > 0 and bShowPivotPoints
            draw_line(i, s5, DEF_COLOR)


// indicator(title='Everest', shorttitle='Everest', overlay=true)

// Inspired by this video: https://www.youtube.com/watch?v=a7Hd0b5grZs

// ==============================   SMOOTHED HA   ====================================

g_TimeframeSettings = 'Display & Timeframe Settings'
time_frame = input.timeframe(title='Timeframe for HA candle calculation', defval='', group=g_TimeframeSettings) 
g_SmoothedHASettings = 'Smoothed HA Settings'
smoothedHALength = input.int(title='HA Price Input Smoothing Length', minval=1, maxval=500, step=1, defval=13, group=g_SmoothedHASettings)
smoothedMAType = input.string(title='Moving Average Calculation', group=g_SmoothedHASettings, options=['Exponential', 'Simple', 'Smoothed', 'Weighted', 'Linear', 'Hull', 'Arnaud Legoux'], defval='Exponential')
smoothedHAalmaSigma = input.float(title="ALMA Sigma", defval=6, minval=0, maxval=100, step=0.1, group=g_SmoothedHASettings)
smoothedHAalmaOffset = input.float(title="ALMA Offset", defval=0.85, minval=0, maxval=1, step=0.01, group=g_SmoothedHASettings)
g_DoubleSmoothingSettings = 'Double-smoothed HA Settings'
doDoubleSmoothing = input.bool(title='Enable double-smoothing', defval=true, group=g_DoubleSmoothingSettings)
doubleSmoothedHALength = input.int(title='HA Second Smoothing Length', minval=1, maxval=500, step=1, defval=10, group=g_DoubleSmoothingSettings)
doubleSmoothedMAType = input.string(title='Double-Smoothing Moving Average Calculation', group=g_DoubleSmoothingSettings, options=['Exponential', 'Simple', 'Smoothed', 'Weighted', 'Linear', 'Hull', 'Arnaud Legoux'], defval='Exponential')
doubleSmoothedHAalmaSigma = input.float(title="ALMA Sigma", defval=6, minval=0, maxval=100, step=0.1, group=g_DoubleSmoothingSettings)
doubleSmoothedHAalmaOffset = input.float(title="ALMA Offset", defval=0.85, minval=0, maxval=1, step=0.01, group=g_DoubleSmoothingSettings)

smoothedMovingAvg(src, len) => 
	smma = 0.0
	smma := na(smma[1]) ? ta.sma(src, len) : (smma[1] * (len - 1) + src) / len 
	smma
	
getHAOpen(prevOpen, prevClose) =>
    haOpen = 0.0
    haOpen := ((prevOpen + prevClose)/2)
    haOpen

getHAHigh(o, h, c) =>
    haHigh = 0.0
    haHigh := math.max(h, o, c)
    haHigh

getHALow(o, l, c) =>
    haLow = 0.0
    haLow := math.min(o, l, c)
    haLow
    
getHAClose(o, h, l, c) =>
    haClose = 0.0
    haClose := ((o + h + l + c)/4)
    haClose
	
getMAValue(src, len, type, isDoubleSmooth) =>
	maValue = 0.0
	if (type == 'Exponential')
		maValue := ta.ema(source=src, length=len)
	else if (type == 'Simple')
		maValue := ta.sma(source=src, length=len)
	else if (type == 'Smoothed')
		maValue := smoothedMovingAvg(src=src, len=len)
	else if (type == 'Weighted')
		maValue := ta.wma(source=src, length=len)
	else if (type == 'Linear')
		maValue := ta.linreg(source=src, length=len, offset=0)
	else if (type == 'Hull')
		maValue := ta.hma(source=src, length=len)
	else if (type == 'Arnaud Legoux')
		maValue := ta.alma(series=src, length=len, offset=(isDoubleSmooth ? doubleSmoothedHAalmaOffset : smoothedHAalmaOffset), sigma=(isDoubleSmooth ? doubleSmoothedHAalmaSigma : smoothedHAalmaSigma))
	else 
		maValue := na
	maValue

realPriceTicker = ticker.new(prefix=syminfo.prefix, ticker=syminfo.ticker)
actualOpen = request.security(symbol=realPriceTicker, timeframe=time_frame, expression=open, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
actualHigh = request.security(symbol=realPriceTicker, timeframe=time_frame, expression=high, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
actualLow = request.security(symbol=realPriceTicker, timeframe=time_frame, expression=low, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
actualClose = request.security(symbol=realPriceTicker, timeframe=time_frame, expression=close, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)

smoothedMA1open = getMAValue(actualOpen, smoothedHALength, smoothedMAType, false) 
smoothedMA1high = getMAValue(actualHigh, smoothedHALength, smoothedMAType, false) 
smoothedMA1low = getMAValue(actualLow, smoothedHALength, smoothedMAType, false) 
smoothedMA1close = getMAValue(actualClose, smoothedHALength, smoothedMAType, false)
smoothedHAClose = getHAClose(smoothedMA1open, smoothedMA1high, smoothedMA1low, smoothedMA1close)

smoothedHAOpen = smoothedMA1open
smoothedHAOpen := na(smoothedHAOpen[1]) ? smoothedMA1open : getHAOpen(smoothedHAOpen[1], smoothedHAClose[1])
smoothedHAHigh = getHAHigh(smoothedHAOpen, smoothedMA1high, smoothedHAClose)
smoothedHALow =  getHALow(smoothedHAOpen, smoothedMA1low, smoothedHAClose)

openToPlot = smoothedHAOpen
closeToPlot = smoothedHAClose
highToPlot = smoothedHAHigh
lowToPlot = smoothedHALow

if (doDoubleSmoothing)
    openToPlot := getMAValue(smoothedHAOpen, doubleSmoothedHALength, doubleSmoothedMAType, true)
    closeToPlot := getMAValue(smoothedHAClose, doubleSmoothedHALength, doubleSmoothedMAType, true)
    highToPlot := getMAValue(smoothedHAHigh, doubleSmoothedHALength, doubleSmoothedMAType, true)
    lowToPlot := getMAValue(smoothedHALow, doubleSmoothedHALength, doubleSmoothedMAType, true)
else
    na

candleColor = color.rgb(0, 0, 0, 100)
// candleColor := (closeToPlot > openToPlot) ? colorBullish : (closeToPlot < openToPlot) ? colorBearish : candleColor[1]

// ===================================   DXF   ======================================================

f_avgdxf(_price, _length, _vol, _avg) =>
    mf              = ta.change(_price) * _vol
    SumAbsChange    = math.sum(math.abs(mf), _length)
    SumUpChange     = math.sum(math.max(mf, 0), _length)
    o_dxf           = SumUpChange / SumAbsChange * 200 - 100
    o_avgdxf        = ta.wma(o_dxf, _avg)

price       = input(close, 'Price')
lookbk      = input.int(15, 'DXF Lookback', minval=1)
lengthE     = input.int(5, 'Avg Length', minval=1)
smth        = input.int(3, 'Smooth', minval=1)
step        = input.int(20, 'Step [0 = No Step]', minval=0, step=5)
s_level     = input(20, 'Significant Trend Level')
vol_w       = input(false, 'Volume Weighted?')

v           = vol_w ? volume : 1                                   
dxf_raw     = f_avgdxf(price, lookbk, v, lengthE)
dxf_s       = ta.wma(dxf_raw, smth)                                
dxf         = step > 0 ? math.round(dxf_s / step) * step : dxf_s

c_up        = color.new(#33ff00, 0)
c_dn        = color.new(#ff1111, 0)
upDXF       = dxf >= 0
downDXF     = dxf < 0
c_zeroline  = color.new(color.yellow, 70)


// =====================================   REDK EVEREX 2.0   ====================================================

GetAverage(_data, _len, MAOption) =>
    value = switch MAOption
        'SMA' => ta.sma(_data, _len) 
        'EMA' => ta.ema(_data, _len) 
        'HMA' => ta.hma(_data, _len) 
        'RMA' => ta.rma(_data, _len) 
        => 
            ta.wma(_data, _len)

Normalize(_Value, _Avg) =>
    _X = _Value / _Avg
    _Nor = 
      _X > 1.50 ? 1.00 :
      _X > 1.20 ? 0.90 :
      _X > 1.00 ? 0.80 :
      _X > 0.80 ? 0.70 :
      _X > 0.60 ? 0.60 :
      _X > 0.40 ? 0.50 :
      _X > 0.20 ? 0.25 :
      0.1

grp_1   = 'Rate of FLow (RoF)'
grp_2   = 'Lookback Parameters'
grp_3   = 'Bias / Sentiment'
grp_4   = 'EVEREX Bands'

length1    = input.int(10, minval = 1, inline = 'ROF', group = grp_1)
MA_Type   = input.string(defval = 'WMA', title = 'MA type', 
  options = ['WMA', 'EMA', 'SMA', 'HMA', 'RMA'], inline = 'ROF', group = grp_1) 
smooth    = input.int(defval = 3, title = 'Smooth', minval = 1,  inline = 'ROF', group = grp_1)

sig_length  = input.int(5, 'Signal Length', minval = 1, inline = 'Signal', group = grp_1)
S_Type      = input.string(defval = 'WMA', title = 'Signal Type', 
  options = ['WMA', 'EMA', 'SMA', 'HMA', 'RMA'], inline = 'Signal', group = grp_1)

lookback    = input.int(defval = 20, title = 'Length', minval = 1, inline = 'Lookback', group = grp_2)
lkbk_Calc   = input.string(defval = 'Simple', title = 'Averaging', 
  options = ['Simple', 'Same as RRoF'], inline='Lookback', group = grp_2 )

showBias    = input.bool(defval = false, title = 'Bias Plot ? -- ', inline = 'Bias', group = grp_3)
B_Length    = input.int(defval = 30, title = 'Length', minval = 1, inline = 'Bias', group = grp_3)
B_Type      = input.string(defval = 'WMA', title = 'MA type', 
  options = ['WMA', 'EMA', 'SMA', 'HMA', 'RMA'], inline = 'Bias', group = grp_3)

showEVEREX  = input.bool(true, 'Show EVEREX Bands ? -- ', inline = 'EVEREX', group = grp_4)

bandscale   = str.tonumber(input.string("100", title = "Band Scale", 
  options = ['100', '200', '400'], inline = 'EVEREX', group = grp_4))

DispBias    = showBias ? display.pane : display.none 
DispBands   = showEVEREX ? display.pane : display.none 
showhlines  = showEVEREX ? display.all : display.none 

Disp_vals   = display.status_line + display.data_window

v1   = na(volume) ? 1 : volume                  // this part ensures we're not hit with calc issues due to NaN's
NoVol_Flag = na(volume) ? true : false          // this is a flag to use later 

lkbk_MA_Type = lkbk_Calc == 'Simple' ? 'SMA' : MA_Type

Vola  = GetAverage(v1, lookback, lkbk_MA_Type)
Vola_n_pre = Normalize(v1, Vola) * 100
Vola_n = NoVol_Flag ? 100 : Vola_n_pre

BarSpread = close - open 
BarRange  = high - low
R2        = ta.highest(2) - ta.lowest(2)
SrcShift  = ta.change(close)

sign_shift = math.sign(SrcShift) 
sign_spread = math.sign(BarSpread) 
barclosing  = 2 * (close - low) / BarRange * 100 - 100
s2r = BarSpread / BarRange * 100

BarSpread_abs   = math.abs(BarSpread)
BarSpread_avg   = GetAverage(BarSpread_abs, lookback, lkbk_MA_Type)
BarSpread_ratio_n = Normalize(BarSpread_abs, BarSpread_avg) * 100 * sign_spread  
barclosing_2  = 2 * (close - ta.lowest(2)) / R2 * 100 - 100
Shift2Bar_toR2 = SrcShift / R2 * 100 

SrcShift_abs    = math.abs(SrcShift)
srcshift_avg    = GetAverage(SrcShift_abs, lookback, lkbk_MA_Type) 
srcshift_ratio_n   = Normalize(SrcShift_abs, srcshift_avg) * 100 * sign_shift

Pricea_n = (barclosing + s2r + BarSpread_ratio_n + barclosing_2 + Shift2Bar_toR2 + srcshift_ratio_n) / 6
bar_flow  =   Pricea_n * Vola_n / 100 

bulls = math.max(bar_flow, 0)
bears = -1 * math.min(bar_flow, 0)

bulls_avg = GetAverage(bulls, length1, MA_Type)
bears_avg = GetAverage(bears, length1, MA_Type)

dx          = bulls_avg / bears_avg
RROF         = 2 * (100 - 100 / (1 + dx)) - 100
RROF_s      = ta.wma(RROF, smooth)

Signal = GetAverage(RROF_s, sig_length, S_Type)

dx_b          = GetAverage(bulls, B_Length, B_Type) / GetAverage(bears, B_Length, B_Type)
RROF_b       = 2 * (100 - 100 / (1 + dx_b)) - 100
RROF_bs      = ta.wma(RROF_b, smooth)

up1      = RROF_s >= 0
s_up1    = RROF_bs >=0 

Eq_band_option = input.string("Joint", title = 'Band Option', options = ["Joint", "Separate"], group = grp_4)

nPrice  = math.max(math.min(Pricea_n, 100), -100)
nVol    = math.max(math.min(Vola_n, 100), -100)

bar = bar_flow

c_vol_grn   = color.new(#26a69a, 75)
c_vol_red   = color.new(#ef5350, 75)

cb_vol_grn  = color.new(#26a69a, 20)
cb_vol_red  = color.new(#ef5350, 20)

c_vol       = bar > 0 ? c_vol_grn : c_vol_red
cb_vol      = bar > 0 ? cb_vol_grn : cb_vol_red

vc_lo       = 0
vc_hi       = nVol * bandscale / 100 / 2

c_pri_grn   = color.new(#3ed73e, 75)
c_pri_red   = color.new(#ff870a, 75)

cb_pri_grn  = color.new(#3ed73e, 20)
cb_pri_red  = color.new(#ff870a, 20)

c_pri       = bar > 0 ? c_pri_grn : c_pri_red
cb_pri      = bar > 0 ? cb_pri_grn : cb_pri_red

pc_lo_base  = Eq_band_option == "Joint" ? vc_hi : 0.50 * bandscale

pc_lo       = pc_lo_base
pc_hi       = pc_lo_base + math.abs(nPrice) * bandscale / 100 / 2

Alert_up    = ta.crossover(RROF_s,0)
Alert_dn    = ta.crossunder(RROF_s,0)
Alert_swing = ta.cross(RROF_s,0)

nPrice_abs = math.abs(nPrice)
EV_Ratio = 100 * nPrice_abs / nVol
is_positive     = nPrice > 0

is_Compression  = EV_Ratio <= 50
is_EoM          = EV_Ratio >= 120


// =====================================   VODKA SHOT   ==================================================================

var isLong = false
var isShort = false

// ===================================  NEGLECTED VOL by DGT  ======================================--

nzVolume = nz(volume)
source5   = barstate.isconfirmed ? close : close[1]
vsource  = nzVolume ? barstate.isconfirmed ? ta.obv : ta.obv[1] : na
corr     = ta.correlation(source5, vsource, 14)
volAvgS  = ta.sma(nzVolume, 14)
volAvgL  = ta.sma(nzVolume, 14 * 5)
volDev   = (volAvgL + 1.618034 * ta.stdev(volAvgL, 14 * 5)) / volAvgL * 11 / 100
volRel   = nzVolume / volAvgL
momentum = ta.change(vsource, 14) / 14
momOsc   = ta.linreg(momentum / volAvgS * 1.618034, 5, 0)

vbcbColor = if close < open
    if nzVolume > volAvgS * 1.618034
        #910000
    else if nzVolume >= volAvgS * .618034 and nzVolume <= volAvgS * 1.618034
        color.red
    else
        color.orange
else
    if nzVolume > volAvgS * 1.618034
        #006400
    else if nzVolume >= volAvgS * .618034 and nzVolume <= volAvgS * 1.618034
        color.green
    else
        #7FFFD4

bColor5 = color.new(color.black, 25)
gColor = color.new(color.gray, 50)

// ===================================  RedK Dual VADER with Energy Bars [VADER-DEB]  ======================================--

f_derma(_data, _len, MAOption) =>
    value = 
      MAOption == 'SMA' ? ta.sma(_data, _len) :
      MAOption == 'EMA' ? ta.ema(_data, _len) :
      ta.wma(_data, _len)

rlength  = input.int(12, minval=1)
DER_avg = input.int(5, 'Average', minval=1, inline='DER', group='Directional Energy Ratio')
MA_Type5 = input.string('WMA', 'DER MA type', options=['WMA', 'EMA', 'SMA'], inline='DER', group='Directional Energy Ratio') 
rsmooth  = input.int(3, 'Smooth', minval=1,  inline='DER_1', group='Directional Energy Ratio')

show_senti = input.bool(true, 'Sentiment',  inline='DER_s', group='Directional Energy Ratio')
senti   = input.int(20, 'Length', minval=1, inline='DER_s', group='Directional Energy Ratio')

v_calc  = input.string('Relative', 'Calculation', options=['Relative', 'Full', 'None'], group='Volume Parameters')
vlookbk = input.int(20, 'Lookback (for Relative)', minval=1,                            group='Volume Parameters')

v5 = volume

vola    = 
  v_calc == 'None' or na(volume) ? 1 : 
  v_calc == 'Relative' ?   ta.stoch(v5, v5, v5, vlookbk) / 100 : 
  v5

R       = (ta.highest(2) - ta.lowest(2)) / 2                    // R is the 2-bar average bar range - this method accomodates bar gaps
sr      = ta.change(close) / R                                  // calc ratio of change to R
rsr     = math.max(math.min(sr, 1), -1)                         // ensure ratio is restricted to +1/-1 in case of big moves
c       = fixnan(rsr * vola)                                    

c_plus  = math.max(c, 0)                                        // calc directional vol-accel energy
c_minus = -math.min(c, 0)

avg_vola    = f_derma(vola, rlength, MA_Type5)
dem         = f_derma(c_plus, rlength, MA_Type5)  / avg_vola          // directional energy ratio
sup         = f_derma(c_minus, rlength, MA_Type5) / avg_vola

adp         = 100 * ta.wma(nz(dem), DER_avg)                        // average DER
asp         = 100 * ta.wma(nz(sup), DER_avg)
anp         = adp - asp                                             // net DER..
anp_s       = ta.wma(anp, rsmooth)

s_adp       = 100 * ta.wma(nz(dem), senti)                            // average DER for sentiment length
s_asp       = 100 * ta.wma(nz(sup), senti)
V_senti     = ta.wma(s_adp - s_asp, rsmooth)

c_adp   = color.new(#11ff20, 30)
c_asp   = color.new(#ff1111, 30)
c_fd    = color.new(color.green, 80)
c_fs    = color.new(color.red, 80)
c_zero  = color.new(#ffee00, 70)

c_up5    = color.new(#11ff20, 0)
c_dn5    = color.new(#ff1111, 0)

up5      = anp_s >= 0
s_up    = V_senti >= 0 

c_grow_above = #1b5e2080 
c_grow_below = #dc4c4a80
c_fall_above = #66bb6a80  
c_fall_below = #ef8e9880     

sflag_up = math.abs(V_senti) >= math.abs(V_senti[1])

bo = fixnan(asp)
bc = fixnan(adp)
bh = math.max(bo, bc)
bl = math.min(bo, bc)

rising      = ta.change(bc) > 0

c_barup     = #11ff2088
c_bardn     = #ff111188
c_bardj     = #ffffff88

barcolor    = bc > bo and rising ? c_barup : bc < bo and not rising ? c_bardn : c_bardj

// ===================================  RedK Slow_Smooth WMA, RSS_WMA v3 ======================================--

f_LazyLine(_data, _length) =>
    w1 = 0, w2 = 0, w3 = 0
    L1 = 0.0, L2 = 0.0, L3 = 0.0
    w = _length / 3
    
    if _length > 2 
        w2 := math.round(w)
        w1 := math.round((_length-w2)/2)
        w3 :=   int((_length-w2)/2)
        
        L1 := ta.wma(_data, w1)
        L2 := ta.wma(L1, w2)
        L3 := ta.wma(L2, w3)
    else
        L3 := _data
    L3

LL = f_LazyLine(close, 21)

lc_up        = color.new(#33ff00, 0)
lc_dn        = color.new(#ff1111, 0)
luptrend     = LL > LL[1]
SigMulti    = 1.0

SignalOn    = barstate.isconfirmed 
SwingDn     = luptrend[1] and not(luptrend) and barstate.isconfirmed 
SwingUp     = luptrend and not(luptrend[1]) and barstate.isconfirmed 

dl = SigMulti / 100 * LL  

upwards = LL > LL[1] and (barcolor == c_barup) and up and (open < close and volRel * .145898 > volDev) and not isLong
downwards = LL < LL[1]  and (barcolor == c_bardn) and (open > close and volRel * .145898 > volDev) and not isShort

showUp = upwards and not upwards[1] and not upwards[2] and not upwards[3] and not upwards[4] 
showDown = downwards and not downwards[1] and not upwards[2] and not upwards[3] and not upwards[4] 

plotshape(bShowVodka and showUp ? 1 : na, title="VodkaShot", text="V", location=location.belowbar, style=shape.labelup, size=size.tiny, color=color.green, textcolor=color.white)
plotshape(bShowVodka and showDown ? 1 : na, title="VodkaShot", text="V", location=location.abovebar, style=shape.labeldown, size=size.tiny, color=color.red, textcolor=color.white)

if showUp
    isLong := true
    isShort := false

if showDown
    isLong := false
    isShort := true

// =====================================  EVEREST  ==================================================================

upwards5 = upDXF and up1 and (closeToPlot > openToPlot) and pc_hi > 74 and bar > 0 and barstate.isconfirmed
downwards5 = downDXF and not up1 and (closeToPlot < openToPlot) and pc_hi > 74 and bar < 0 and barstate.isconfirmed

showUp5 = upwards5 and not upwards5[1] and not upwards5[2] and not upwards5[3] and not upwards5[4] 
showDown5 = downwards5 and not downwards5[1] and not upwards5[2] and not upwards5[3] and not upwards5[4] 

plotshape(bShowEverest and showUp5 ? 1 : na, title="Everest", text="E", location=location.belowbar, style=shape.labelup, size=size.tiny, color=color.green, textcolor=color.white)
plotshape(bShowEverest and showDown5 ? 1 : na, title="Everest", text="E", location=location.abovebar, style=shape.labeldown, size=size.tiny, color=color.red, textcolor=color.white)

e1 = ta.ema(close, 200)
plot(bShowEMA ? e1 : na, "200 EMA", color=color.rgb(161, 161, 161), linewidth=2)
plot(bShowEMA ? ta.vwap(close) : na, "VWAP", color=color.blue, linewidth=3)


// =====================================   JOHN WICK SETTINGS  ==================================================================

upWick50PercentLarger = close > open and math.abs(high - close) > math.abs(open - close)
downWick50PercentLarger = close < open and math.abs(low - close) > math.abs(open - close)

// JOHN WICK BOLLINGER BANDS
wlengthBB = input.int(20, minval=1, group="Wicking Bollinger Bands")
wsrcBB = input(close, title="Source", group="Wicking Bollinger Bands")
wmultBB = input.float(2.5, minval=0.001, maxval=50, title="StdDev", group="Wicking Bollinger Bands")
woffsetBB = input.int(0, "Offset", minval = -500, maxval = 500, group="Wicking Bollinger Bands")
wbasisBB = ta.sma(wsrcBB, wlengthBB)
wdevBB = wmultBB * ta.stdev(wsrcBB, wlengthBB)
wupperBB = wbasisBB + wdevBB
wlowerBB = wbasisBB - wdevBB

plotchar(low <= wlowerBB and close >= wlowerBB and close < open and bUseBB ? 1 : na, char="ÃŸ", title="Bollinger Bands", location=location.belowbar, size=size.tiny, color=color.lime)
plotchar(high >= wupperBB and close < wupperBB and close > open and bUseBB ? 1 : na, char="ÃŸ", title="Bollinger Bands", location=location.abovebar, size=size.tiny, color=color.red)


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=  CCI / RSI  =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= //

lCCI = input.int(20, minval=1, group="CCI")
srcCCI = input.source(hlc3, title="Source", group="CCI")
ma2 = ta.sma(srcCCI, lCCI)
cci = (srcCCI - ma2) / (0.015 * ta.dev(srcCCI, lCCI))
cciColor = cci >= 100 ? #288a75 : cci <= -100 ? color.red : color.new(color.black, 100)
Rsi2 = ta.rsi(close, 14)

plotchar(upWick50PercentLarger and Rsi2 > rsiUpperW and bUseRSI ? 1 : na, title="RSI", char="Åž", location=location.abovebar, size=size.tiny, color=color.red)
plotchar(downWick50PercentLarger and Rsi2 < rsiLowerW and bUseRSI ? 1 : na, title="RSI", char="Åž", location=location.belowbar, size=size.tiny, color=color.lime)


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=  KELTNER CHANNEL  =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= //
esma(sourceKC, lengthKC)=>
	s = ta.sma(sourceKC, lengthKC)
	e = ta.ema(sourceKC, lengthKC)
	e
maKC = esma(close, lengthKC)
rangema2 = ta.tr(true) 
upperKC2 = maKC + rangema2 * multKC
lowerKC2 = maKC - rangema2 * multKC

plotshape(low <= lowerKC2 and close >= lowerKC2 and close < open and bUseKC ? 1 : na, title="Keltner Channel", location=location.belowbar, style=shape.labeldown, size=size.tiny, color=color.lime)
plotshape(high >= upperKC2 and close < upperKC2 and close > open and bUseKC ? 1 : na, title="Keltner Channel", location=location.abovebar, style=shape.labelup, size=size.tiny, color=color.red)


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=   ALERTS   =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= //

alertcondition(showUp5, title='Everest BUY', message='Everest BUY')
alertcondition(showDown5, title='Everest SELL', message='Everest SELL')

alertcondition(showUp, title='Vodka BUY', message='Vodka BUY')
alertcondition(showDown, title='Vodka SELL', message='Vodka SELL')

alertcondition(upThrust, title='Trampoline BUY', message='Trampoline BUY')
alertcondition(downThrust, title='Trampoline SELL', message='Trampoline SELL')

alertcondition(bVectorGreen, title='Vector Candle GREEN', message='Vector Candle GREEN')
alertcondition(bVectorRed, title='Vector Candle RED', message='Vector Candle RED')

alertcondition(buySignal1, title='Squeeze BUY', message='Squeeze BUY')
alertcondition(sellSignal1, title='Squeeze SELL', message='Squeeze SELL')

alertcondition(bShowShark and bShowSharkUp, title='Shark BUY', message='Shark BUY')
alertcondition(bShowShark and bShowSharkDown, title='Shark SELL', message='Shark SELL')


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=   CLOUD ALERTS   =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= //

alertcondition((bBrokeDown and buySignal1) or (bBrokeUp and sellSignal1), title='Squeeze in Cloud', message='Squeeze in Cloud')
alertcondition((bBrokeDown and downThrust) or (bBrokeUp and upThrust), title='Trampoline in Cloud', message='Trampoline in Cloud')
alertcondition((bBrokeUp and upWick50PercentLarger) or (bBrokeDown and downWick50PercentLarger), title='Large Wick in Cloud', message='Large Wick in Cloud')


